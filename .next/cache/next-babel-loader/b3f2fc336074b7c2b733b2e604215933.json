{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport * as actionTypes from \"../actions/actionTypes\";\nimport { updateObject, shuffleCards } from \"../../shared/utility\";\nvar initialState = {\n  cards: [],\n  noOfPairs: 10,\n  score: 0,\n  noOfTries: 0,\n  flippedCardsId: [],\n  matchedCards: [],\n  selectedIndex: null,\n  gameOver: false\n}; //a reducer to set number of pairs on user select\n\nvar setNoOfPairs = function setNoOfPairs(state, action) {\n  return updateObject(initialState, {\n    noOfPairs: action.number\n  });\n}; //this to generate array with the length of (no of pairs*2) and shuffle it\n\n\nvar createDeck = function createDeck(state, action) {\n  var cardList = [];\n\n  for (var i = 1; i <= state.noOfPairs; i++) {\n    cardList.push({\n      id: i + \"-1\",\n      name: \"pair-\".concat(i),\n      flipped: true,\n      matched: false\n    });\n    cardList.push({\n      id: i + \"-2\",\n      name: \"pair-\".concat(i),\n      flipped: true,\n      matched: false\n    });\n  }\n\n  return updateObject(state, {\n    cards: shuffleCards(cardList),\n    flippedCardsId: Array.from(Array(2 * state.noOfPairs).keys())\n  });\n};\n\nvar hideCards = function hideCards(state, action) {\n  var cardsHided = state.cards.map(function (card) {\n    return _objectSpread(_objectSpread({}, card), {}, {\n      flipped: false\n    });\n  });\n  return updateObject(state, {\n    cards: cardsHided,\n    flippedCardsId: []\n  });\n}; //function to set flipped to true when the user clicks a card\n\n\nvar flipCard = function flipCard(state, action) {\n  if (state.flippedCardsId.length == 2) return;\n  var temp = state.cards;\n  state.cards[action.index].flipped = true;\n  temp[action.index].flipped = true;\n  return updateObject(state, {\n    flippedCardsId: [].concat(_toConsumableArray(state.flippedCardsId), [action.index]),\n    selectedIndex: action.index\n  });\n}; //a function to restart the game\n\n\nvar restartGame = function restartGame(state, action) {\n  return updateObject(initialState, {\n    gameOver: false,\n    noOfPairs: state.noOfPairs\n  });\n}; //when two cards match, add the indexes to the matched array and set card.match=true\n\n\nvar matchedCards = function matchedCards(state, action) {\n  var matched = [].concat(_toConsumableArray(state.matchedCards), _toConsumableArray(state.flippedCardsId));\n  state.cards[state.flippedCardsId[0]].matched = true;\n  state.cards[state.selectedIndex].matched = true;\n  return updateObject(state, {\n    flippedCardsId: [],\n    selectedIndex: null,\n    matchedCards: matched,\n    noOfTries: state.noOfTries + 1,\n    score: state.score + 1,\n    gameOver: matched.length === 2 * state.noOfPairs\n  });\n}; //a function to reset the cards again after checkMatch\n\n\nvar resetCards = function resetCards(state, action) {\n  return updateObject(state, {\n    flippedCardsId: [],\n    selectedIndex: null,\n    noOfTries: state.noOfTries + 1\n  });\n};\n\nvar initDeck = function initDeck() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case actionTypes.FLIP_CARD:\n      return flipCard(state, action);\n\n    case actionTypes.CREATE_DECK:\n      return createDeck(state, action);\n\n    case actionTypes.HIDE_CARDS:\n      return hideCards(state, action);\n\n    case actionTypes.MATCHED_CARDS:\n      return matchedCards(state, action);\n\n    case actionTypes.RESET_CARDS:\n      return resetCards(state, action);\n\n    case actionTypes.RESTART_GAME:\n      return restartGame(state, action);\n\n    case actionTypes.SET_NO_OF_PAIRS:\n      return setNoOfPairs(state, action);\n\n    default:\n      return state;\n  }\n};\n\nexport default initDeck;","map":{"version":3,"sources":["/Users/enassamir/Desktop/find-the-pairs-game/src/store/reducers/Deck.js"],"names":["actionTypes","updateObject","shuffleCards","initialState","cards","noOfPairs","score","noOfTries","flippedCardsId","matchedCards","selectedIndex","gameOver","setNoOfPairs","state","action","number","createDeck","cardList","i","push","id","name","flipped","matched","Array","from","keys","hideCards","cardsHided","map","card","flipCard","length","temp","index","restartGame","resetCards","initDeck","type","FLIP_CARD","CREATE_DECK","HIDE_CARDS","MATCHED_CARDS","RESET_CARDS","RESTART_GAME","SET_NO_OF_PAIRS"],"mappings":"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","sourcesContent":["import * as actionTypes from \"../actions/actionTypes\";\nimport { updateObject, shuffleCards } from \"../../shared/utility\";\n\nconst initialState = {\n  cards: [],\n  noOfPairs: 10,\n  score: 0,\n  noOfTries: 0,\n  flippedCardsId: [],\n  matchedCards: [],\n  selectedIndex: null,\n  gameOver: false\n};\n\n//a reducer to set number of pairs on user select\nconst setNoOfPairs = (state, action) => {\n  return updateObject(initialState, { noOfPairs: action.number });\n};\n\n//this to generate array with the length of (no of pairs*2) and shuffle it\nconst createDeck = (state, action) => {\n  let cardList = [];\n  for (let i = 1; i <= state.noOfPairs; i++) {\n    cardList.push({ id: i + \"-1\", name: `pair-${i}`, flipped: true, matched: false });\n    cardList.push({ id: i + \"-2\", name: `pair-${i}`, flipped: true, matched: false });\n  }\n  return updateObject(state, {\n    cards: shuffleCards(cardList),\n    flippedCardsId: Array.from(Array(2 * state.noOfPairs).keys()),\n  });\n};\n\nconst hideCards = (state, action) => {\n  let cardsHided = state.cards.map((card) => {\n    return { ...card, flipped: false };\n  });\n  return updateObject(state, {\n    cards: cardsHided,\n    flippedCardsId: [],\n  });\n};\n\n//function to set flipped to true when the user clicks a card\nconst flipCard = (state, action) => {\n  if (state.flippedCardsId.length == 2) return;\n\n  let temp = state.cards;\n  state.cards[action.index].flipped = true;\n  temp[action.index].flipped = true;\n  return updateObject(state, {\n    flippedCardsId: [...state.flippedCardsId, action.index],\n    selectedIndex: action.index,\n  });\n};\n\n//a function to restart the game\nconst restartGame = (state, action) => {\n  return updateObject(initialState, { gameOver: false, noOfPairs:state.noOfPairs });\n};\n\n//when two cards match, add the indexes to the matched array and set card.match=true\nconst matchedCards = (state, action) => {\n  let matched = [...state.matchedCards, ...state.flippedCardsId];\n\n  state.cards[state.flippedCardsId[0]].matched = true;\n  state.cards[state.selectedIndex].matched = true;\n\n  return updateObject(state, {\n    flippedCardsId: [],\n    selectedIndex: null,\n    matchedCards: matched,\n    noOfTries: state.noOfTries + 1,\n    score: state.score + 1,\n    gameOver: matched.length === 2 * state.noOfPairs,\n  });\n};\n\n//a function to reset the cards again after checkMatch\nconst resetCards = (state, action) => {\n  return updateObject(state, {\n    flippedCardsId: [],\n    selectedIndex: null,\n    noOfTries: state.noOfTries + 1,\n  });\n};\n\nconst initDeck = (state = initialState, action) => {\n  switch (action.type) {\n    case actionTypes.FLIP_CARD:\n      return flipCard(state, action);\n    case actionTypes.CREATE_DECK:\n      return createDeck(state, action);\n    case actionTypes.HIDE_CARDS:\n      return hideCards(state, action);\n    case actionTypes.MATCHED_CARDS:\n      return matchedCards(state, action);\n    case actionTypes.RESET_CARDS:\n      return resetCards(state, action);\n    case actionTypes.RESTART_GAME:\n      return restartGame(state, action);\n    case actionTypes.SET_NO_OF_PAIRS:\n      return setNoOfPairs(state, action);\n    default:\n      return state;\n  }\n};\n\nexport default initDeck;\n"]},"metadata":{},"sourceType":"module"}